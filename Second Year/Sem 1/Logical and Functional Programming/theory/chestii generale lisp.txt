(defun g(l))

g-symbolul g
'g-cum se evalueaza expresia g, adica se executa functia.
funcall g apeleaza o functie stored in a variable, aici g.

 (print '(abc)) = (ABC)

 (print 'abc) = ABC

'(abc), abc=atom
'(a b c)-3 elem

APPEND FLATTENS ALL LEVELS

(defun f (x &rest y))-asta inseamna ca daca dai mai multi param toti se baga in lista y




mapcan si mapcon opereaza pe sublistele argumentului, iar rezultatele primite pe care le concateneaza intr-o singura lista trgb sa fie tot liste. (ex: lamba trb sa returneze liste). la mapcar si maplist nu trebuie. 

mapcar applies a function to each element of the list(s) and collects the results in a new list. (not wrapper one, it's like a flatten one)
maplist applies a function to each tail of EACH list, and collects he results in a wrapper list. (lucreaza cu liste, rezultatele returnate pot fi ori liste ori numere ori whatever, care sunt bagate intr-o lista mare)
mapcan applies a function to each element of the list, and collects the results in a new list. (not wrapper one, it's like a flatten one)
mapcon applies a function to each tail of the list, and collects the results in a wrapper function
MAPCAN-rezultatul aplicarii functiei pe fiecare sublista va fi tot o lista. la final, mapcan transforma aceste liste (rezultatele) intr-o singura lista. 
ex: 
(mapcan #'(lambda (x y) (if (null x) nil (list x y)))
          '(nil nil nil d e)
          '(1 2 3 4 5 6)) =>  (D 4 E 5) 

rez vor fi: (D 4) (E 5), ca ia elem 4 din l1 cu elem 4 din l2. iar aceste 2 liste le transforma in una singura, adica (D 4 E 5).

(mapcar #'triple '(1 2 3)) => (3 6 9)
(mapcan #'triple '(1)) => 3
(maplist #’triple ‘(1 2 3)) => ((3 6 9) (6 9) (9))   
(mapcon #'triple '(1 2 3)) => (3 6 9 6 9 9)



(mapcar #'car '((1 a) (2 b) (3 c))) =>  (1 2 3) 
 (mapcar #'abs '(3 -4 2 -5 -6)) =>  (3 4 2 5 6)
 (mapcar #'cons '(a b c) '(1 2 3)) =>  ((A . 1) (B . 2) (C . 3))

 (maplist #'append '(1 2 3 4) '(1 2) '(1 2 3)) 
=>  ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3)) 
 (maplist #'(lambda (x) (cons 'foo x)) '(a b c d))
=>  ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))
 (maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c))
=>  (0 0 1 0 1 1 1)
 (mapcan #'(lambda (x y) (if (null x) nil (list x y)))
          '(nil nil nil d e)
          '(1 2 3 4 5 6)) =>  (D 4 E 5) 
 (mapcan #'(lambda (x) (and (numberp x) (list x)))
          '(a 1 b c 3 4 d 5))
=>  (1 3 4 5)

(mapcon #'list '(1 2 3 4)) =>  ((1 2 3 4) (2 3 4) (3 4) (4)) 